#include <SFML/Graphics.hpp>
#include <iostream>
#include <fstream>
#include "board.h"
#include"player.h"
#include "ghost.h"
#include <string>
using namespace std;
using namespace sf;
void main()
{
	srand(unsigned(time(NULL)));
	RenderWindow window;
	window.create(VideoMode(1000, 1000), "PacMan");
	board maze("normalBlock.png", "Blue.jpg", "pallet.png", "powerP.png");
	maze.readArrayFromFile("Board.txt");
	maze.setBoardTextures();
	player player1("pacman", "Pacman.png", 1, 1);
	ghost ghostBlinky("Blinky", "Blinky.png", 8, 9, true);
	ghost ghostPinky("Pinky", "Pinky.png", 9, 9, true);
	ghost ghostInky("Inky", "Inky.png", 9, 8, false);
	ghost ghostClyde("Clyde", "Clyde.png", 9, 10, false);
	//Texture pall, ppall;
	//pall.loadFromFile("pallet.png");//p
	//ppall.loadFromFile("powerP.png");// powerp
	//text.setString(to_string(score));
	Font myFont;
	if (!myFont.loadFromFile("GROBOLD.ttf"))
	{
		cout << "Failed to load font";
	}
	Text score;
	score.setFont(myFont);
	score.setFillColor(sf::Color::Yellow);
	score.setStyle(sf::Text::Bold);
	//score.setString("Score");
	score.setCharacterSize(25);
	score.setPosition(25, 130);
	Text lives;
	lives.setFont(myFont);
	lives.setFillColor(sf::Color::Yellow);
	lives.setStyle(sf::Text::Bold);
	//lives.setString("Score");
	lives.setCharacterSize(25);
	lives.setPosition(25, 160);
	Text end;
	end.setString("");
	end.setFont(myFont);
	end.setFillColor(sf::Color::Yellow);
	end.setStyle(sf::Text::Bold);
	end.setCharacterSize(120);
	end.setPosition(300, 500);
	Clock slow;
	char direction = 'f';
	int start = 0;
	Event e;
	Clock clydeclk;
	Clock Fmode;
	string E;
	string s;
	string l;
	bool clydeCanmove = false;
	bool frenzy = false;
	while (window.isOpen())
	{
		//if statement with start to draw
		if (player1.getScore() >= 3680 || player1.getNumberofLives() < 1)
		{
			if (player1.getScore() >= 3680)
			{
				E = "You Win";
				end.setString(E);
			}
			else
			{
				E = "You Lose";
				end.setString(E);
			}
		}
		if (window.pollEvent(e))
		{

			if (e.type == Event::Closed)
				window.close();
			else if (e.type == Event::KeyPressed)
			{
				switch (e.key.code)
				{
				case Keyboard::Up:
					direction = 'U';
					break;
				case Keyboard::Down:
					direction = 'D';
					break;
				case Keyboard::Right:
					direction = 'R';
					break;
				case Keyboard::Left:
					direction = 'L';
					break;
				case Keyboard::A:
					start = 1;
					break;
				}//move(0,1)
			}
		}
		if (start == 0)
		{
			l = "Lives = " + to_string(player1.getNumberofLives());
			lives.setString(l);
			s = "Points = " + to_string(player1.getScore());
			score.setString(s);
			switch (direction)
			{
			case 'U':
				player1.movePlayer(direction, maze.board1[player1.getPlayerRow() - 1][player1.getPlayerColumn()].type);
				break;
			case 'D':
				player1.movePlayer(direction, maze.board1[player1.getPlayerRow() + 1][player1.getPlayerColumn()].type);
				break;
			case 'R':
				player1.movePlayer(direction, maze.board1[player1.getPlayerRow()][player1.getPlayerColumn() + 1].type);
				break;
			case 'L':
				player1.movePlayer(direction, maze.board1[player1.getPlayerRow()][player1.getPlayerColumn() - 1].type);
				break;
			}
			//pinky moves
			if (ghostPinky.nofmoves == 0)
			{
				ghostPinky.moveGhost('U', tile_type::normalBlock);

			}
			else if (ghostPinky.nofmoves == 1)
			{
				ghostPinky.moveGhost('U', tile_type::normalBlock);
			}
			else if (ghostPinky.nofmoves == 2)
			{
				ghostPinky.moveGhost('L', tile_type::normalBlock);
			}
			else
			{
				int prand = rand() % 4;
				if (prand == 0)//up
					ghostPinky.moveGhost('U', maze.getBoard1CellTexture(ghostPinky.getGhostRow() - 1, ghostPinky.getGhostColumn()));
				if (prand == 1)//down
					ghostPinky.moveGhost('D', maze.getBoard1CellTexture(ghostPinky.getGhostRow() + 1, ghostPinky.getGhostColumn()));
				if (prand == 2)//right
					ghostPinky.moveGhost('R', maze.getBoard1CellTexture(ghostPinky.getGhostRow(), ghostPinky.getGhostColumn() + 1));
				if (prand == 3)//left
					ghostPinky.moveGhost('L', maze.getBoard1CellTexture(ghostPinky.getGhostRow(), ghostPinky.getGhostColumn() - 1));

			}
			//blinky moves
			if (ghostBlinky.nofmoves == 0)
			{
				ghostBlinky.moveGhost('U', tile_type::normalBlock);

			}
			else
			{
				int prand = rand() % 4;
				if (prand == 0)//up
					ghostBlinky.moveGhost('U', maze.getBoard1CellTexture(ghostBlinky.getGhostRow() - 1, ghostBlinky.getGhostColumn()));
				if (prand == 1)//down
					ghostBlinky.moveGhost('D', maze.getBoard1CellTexture(ghostBlinky.getGhostRow() + 1, ghostBlinky.getGhostColumn()));
				if (prand == 2)//right
					ghostBlinky.moveGhost('R', maze.getBoard1CellTexture(ghostBlinky.getGhostRow(), ghostBlinky.getGhostColumn() + 1));
				if (prand == 3)//left
					ghostBlinky.moveGhost('L', maze.getBoard1CellTexture(ghostBlinky.getGhostRow(), ghostBlinky.getGhostColumn() - 1));

			}
			//inky moves
			if (ghostInky.nofmoves == 0)
			{
				ghostInky.moveGhost('R', tile_type::normalBlock);

			}
			else if (ghostInky.nofmoves == 1)
			{
				ghostInky.moveGhost('U', tile_type::normalBlock);
			}
			else if (ghostInky.nofmoves == 2)
			{
				ghostInky.moveGhost('U', tile_type::normalBlock);
			}
			else
			{
				int prand = rand() % 4;
				if (prand == 0)//up
					ghostInky.moveGhost('U', maze.getBoard1CellTexture(ghostInky.getGhostRow() - 1, ghostInky.getGhostColumn()));
				if (prand == 1)//down
					ghostInky.moveGhost('D', maze.getBoard1CellTexture(ghostInky.getGhostRow() + 1, ghostInky.getGhostColumn()));
				if (prand == 2)//right
					ghostInky.moveGhost('R', maze.getBoard1CellTexture(ghostInky.getGhostRow(), ghostInky.getGhostColumn() + 1));
				if (prand == 3)//left
					ghostInky.moveGhost('L', maze.getBoard1CellTexture(ghostInky.getGhostRow(), ghostInky.getGhostColumn() - 1));

			}
			//clyde moves
			if (ghostClyde.nofmoves == 0)
			{
				ghostClyde.moveGhost('L', tile_type::normalBlock);

			}
			else if (ghostClyde.nofmoves == 1)
			{
				ghostClyde.moveGhost('U', tile_type::normalBlock);
			}
			else if (ghostClyde.nofmoves == 2)
			{
				ghostClyde.moveGhost('U', tile_type::normalBlock);
			}
			else
			{
				int prand = rand() % 4;
				if (prand == 0)//up
					ghostClyde.moveGhost('U', maze.getBoard1CellTexture(ghostClyde.getGhostRow() - 1, ghostClyde.getGhostColumn()));
				if (prand == 1)//down
					ghostClyde.moveGhost('D', maze.getBoard1CellTexture(ghostClyde.getGhostRow() + 1, ghostClyde.getGhostColumn()));
				if (prand == 2)//right
					ghostClyde.moveGhost('R', maze.getBoard1CellTexture(ghostClyde.getGhostRow(), ghostClyde.getGhostColumn() + 1));
				if (prand == 3)//left
					ghostClyde.moveGhost('L', maze.getBoard1CellTexture(ghostClyde.getGhostRow(), ghostClyde.getGhostColumn() - 1));

			}
			//ghostBlinky.moveGhost();

			//ghostPinky.moveGhost();
		//	ghostInky.moveGhost();
		//	ghostClyde.moveGhost();
			if (player1.getScore() >= 200 && !ghostInky.canstart)
			{
				ghostInky.canstart = true;
				clydeclk.restart();
			}
			if ((clydeclk.getElapsedTime().asMilliseconds() >= 3000) && (ghostInky.canstart))
				ghostClyde.canstart = true;
			//if (direction == 'U')
			//{

			//RectangleShape r1, r2;
			//r1.getGlobalBounds().intersects(r2.getGlobalBounds());
			if (!frenzy)
			{
				if ((ghostBlinky.getGhostRow() == player1.getPlayerRow()) && (ghostBlinky.getGhostColumn() == player1.getPlayerColumn()) ||
					(ghostPinky.getGhostRow() == player1.getPlayerRow()) && (ghostPinky.getGhostColumn() == player1.getPlayerColumn()) ||
					(ghostInky.getGhostRow() == player1.getPlayerRow()) && (ghostInky.getGhostColumn() == player1.getPlayerColumn()) ||
					(ghostClyde.getGhostRow() == player1.getPlayerRow()) && (ghostClyde.getGhostColumn() == player1.getPlayerColumn()))//problem with frenzy
				{
					player1.ifEaten(1, 1);
					player1.reduceLife();
				}
			}
			if ((maze.getBoard1CellTexture(player1.getPlayerRow(), player1.getPlayerColumn()) == pallett))

			{
				maze.textureAfterPalyerMoves(player1.getPlayerRow(), player1.getPlayerColumn());
				player1.addNumberofPoints(maze.array, maze.arrayOfEmptyPlaces);
				//cout << "points= " << player1.getScore();
			}

			if (maze.getBoard1CellTexture(player1.getPlayerRow(), player1.getPlayerColumn()) == powerpall)
			{
				//if ((maze.getBoard1CellTexture(player1.getPlayerRow(), player1.getPlayerColumn()) == powerpall))

				//{
				maze.textureAfterPalyerMoves(player1.getPlayerRow(), player1.getPlayerColumn());
				player1.addNumberofPoints(maze.array, maze.arrayOfEmptyPlaces);
				//s = "Points= " + to_string(player1.getScore());
				//score.setString(s);
			//}
			//player1.addNumberofPoints(maze.array, maze.arrayOfEmptyPlaces);
				Fmode.restart();
				if (!frenzy)
				{
					ghostBlinky.SetcolorBlueFrenzy("Frenzy.png");
					ghostPinky.SetcolorBlueFrenzy("Frenzy.png");
					ghostInky.SetcolorBlueFrenzy("Frenzy.png");
					ghostClyde.SetcolorBlueFrenzy("Frenzy.png");

				}
				frenzy = true;


			}

			if ((ghostBlinky.getGhostRow() == player1.getPlayerRow()) && (ghostBlinky.getGhostColumn() == player1.getPlayerColumn()))
			{
				ghostBlinky.frenzymodeResetPos(8, 9);

			}

			if ((ghostInky.getGhostRow() == player1.getPlayerRow()) && (ghostInky.getGhostColumn() == player1.getPlayerColumn()))
			{
				ghostInky.frenzymodeResetPos(9, 8);

			}

			if ((ghostClyde.getGhostRow() == player1.getPlayerRow()) && (ghostClyde.getGhostColumn() == player1.getPlayerColumn()))
			{
				ghostClyde.frenzymodeResetPos(9, 10);

			}
			if ((ghostPinky.getGhostRow() == player1.getPlayerRow()) && (ghostPinky.getGhostColumn() == player1.getPlayerColumn()))
			{
				ghostPinky.frenzymodeResetPos(9, 9);

			}
			if (Fmode.getElapsedTime().asSeconds() > 10)
			{
				frenzy = false;
				ghostBlinky.SetColorAFTERfrenzy("Blinky", "Blinky.png");
				ghostClyde.SetColorAFTERfrenzy("Clyde", "Clyde.png");
				ghostInky.SetColorAFTERfrenzy("Inky", "Inky.png");
				ghostPinky.SetColorAFTERfrenzy("Pinky", "Pinky.png");
			}
		}// start function end
		window.clear();
		maze.drawBoardonWindow(window);
		player1.drawPlayerOnWindow(window);
		ghostBlinky.drawGhostonWindow(window);
		ghostPinky.drawGhostonWindow(window);
		ghostInky.drawGhostonWindow(window);
		ghostClyde.drawGhostonWindow(window);
		window.draw(end);
		window.draw(score);
		window.draw(lives);
		window.display();
		slow.restart();
		while (slow.getElapsedTime().asMilliseconds() < 150)
		{
			if (window.pollEvent(e))
			{
				if (e.type == Event::Closed)
					window.close();
				else if (e.type == Event::KeyPressed)
				{
					switch (e.key.code)
					{
					case Keyboard::Up:
						direction = 'U';
						break;
					case Keyboard::Down:
						direction = 'D';
						break;
					case Keyboard::Right:
						direction = 'R';
						break;
					case Keyboard::Left:
						direction = 'L';
						break;
					}//move(0,1)
				}
			}

		}
	}
}
